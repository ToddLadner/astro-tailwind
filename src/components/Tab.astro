---
// Tab.astro
import type { HTMLAttributes } from "astro/types";

interface Props extends HTMLAttributes<"div"> {
  /** Visual label for SR and context */
  label?: string; // e.g., "Music"
  /** Breakpoint where tabs become vertical (accordion-like) */
  verticalAt?: string; // e.g., "(max-width: 640px)"
  classes?: string;
}

const { label = "Tabs", verticalAt = "(max-width: 640px)", classes = "", ...rest } = Astro.props;
---

  <style>
    /* Focus styles for visibility */
    .tabs__tab:focus-visible {
      outline: 2px solid currentColor;
      outline-offset: 2px;
    }
    /* Example Tailwind 4 hooks (keep styling in your CSS):
       .tabs__list { @apply gap-2; }
       .tabs__tab[aria-selected="true"] { @apply bg-neutral-800 text-white; }
       .tabs__tab[aria-selected="false"] { @apply bg-neutral-100 text-neutral-900; }
       [role="tabpanel"] { @apply mt-4; }
    */
    @media (prefers-reduced-motion: reduce) {
      [role="tabpanel"] { transition: none !important; }
    }
  </style>

<div class={`tabs ${classes}`} {...rest}>
  <!-- Tablist will be hydrated from the child sections' data-labels -->
  <div role="tablist" aria-label={label} aria-orientation="horizontal" class="tabs__list flex gap-2 flex-wrap"></div>

  <!--
    Usage: put panels inside the default slot.
    Each panel MUST have:
      id="unique-id"
      data-label="Tab label"
    Example:
      <section id="recent" data-label="Recent">...</section>
  -->
  <slot />

  <script is:inline>
    (() => {
      const root = document.currentScript.closest('.tabs');
      const tablist = root.querySelector('[role="tablist"]');
      const dir = getComputedStyle(document.documentElement).direction || 'ltr';
      const rtl = dir === 'rtl';

      // Collect panels declared by the user
      const panels = [...root.querySelectorAll(':scope > section[id][data-label]')];

      if (panels.length === 0) return;

      // Build tabs from panels
      const tabs = panels.map((panel, idx) => {
        const id = panel.id;
        const label = panel.dataset.label.trim();
        const btn = document.createElement('button');
        btn.type = 'button';
        btn.id = `tab-${id}`;
        btn.setAttribute('role', 'tab');
        btn.setAttribute('aria-controls', id);
        btn.className = 'tabs__tab inline-flex items-center gap-2 px-3 py-2 rounded-md focus:outline-none focus-visible:outline-2';
        btn.textContent = label;
        if (idx === 0) {
          btn.setAttribute('aria-selected', 'true');
          btn.tabIndex = 0;
          panel.hidden = false;
        } else {
          btn.setAttribute('aria-selected', 'false');
          btn.tabIndex = -1;
          panel.hidden = true;
        }
        panel.setAttribute('role', 'tabpanel');
        panel.setAttribute('aria-labelledby', btn.id);
        tablist.appendChild(btn);
        return btn;
      });

      function indexOf(el) { return Math.max(0, tabs.indexOf(el)); }
      function next(i) { return (i + 1) % tabs.length; }
      function prev(i) { return (i - 1 + tabs.length) % tabs.length; }

      function activate(i, { focus = true, updateHash = true } = {}) {
        tabs.forEach((t, j) => {
          const selected = j === i;
          t.setAttribute('aria-selected', String(selected));
          t.tabIndex = selected ? 0 : -1;
          panels[j].hidden = !selected;
        });
        if (focus) tabs[i].focus();
        if (updateHash) history.replaceState(null, '', '#' + panels[i].id);
      }

      // Deep-link on load
      const fromHash = location.hash ? panels.findIndex(p => '#' + p.id === location.hash) : -1;
      if (fromHash >= 0) activate(fromHash, { focus: false, updateHash: false });

      // Click activate
      tabs.forEach((t, i) => t.addEventListener('click', () => activate(i)));

      // Keyboard: Arrow keys + Home/End + type-ahead
      tablist.addEventListener('keydown', (e) => {
        const i = indexOf(document.activeElement);
        if (i < 0) return;

        const labelAt = (idx) => tabs[idx].textContent.trim().toLowerCase();

        switch (e.key) {
          case 'ArrowRight':
            e.preventDefault();
            activate(rtl ? prev(i) : next(i));
            break;
          case 'ArrowLeft':
            e.preventDefault();
            activate(rtl ? next(i) : prev(i));
            break;
          case 'ArrowDown': // when vertical
            e.preventDefault();
            activate(next(i));
            break;
          case 'ArrowUp': // when vertical
            e.preventDefault();
            activate(prev(i));
            break;
          case 'Home':
            e.preventDefault();
            activate(0);
            break;
          case 'End':
            e.preventDefault();
            activate(tabs.length - 1);
            break;
          default:
            if (e.key.length === 1 && /\S/.test(e.key)) {
              const q = e.key.toLowerCase();
              // search forward starting after current
              const order = [...tabs.keys()].map(k => (k + i + 1) % tabs.length);
              const hit = order.find(k => labelAt(k).startsWith(q));
              if (hit != null) {
                e.preventDefault();
                activate(hit);
              }
            }
        }
      });

      // Responsive: set aria-orientation = vertical when small
      const mql = window.matchMedia(`${verticalAt}`);
      function applyOrientation() {
        tablist.setAttribute('aria-orientation', mql.matches ? 'vertical' : 'horizontal');
        // Optional: if vertical and you want Up/Down to be primary, we already support both.
      }
      applyOrientation();
      mql.addEventListener?.('change', applyOrientation);

      // Respect prefers-reduced-motion if you animate with CSS. Panels default to hidden toggle only.
    })();
  </script>

  <noscript>
    <!-- No-JS fallback: show all content with headings.
         This preserves SEO and readability even if JS fails mid-load. -->
    <div class="tabs__noscript space-y-6">
      <slot />
    </div>
  </noscript>
</div>